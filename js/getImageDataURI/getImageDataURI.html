<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>getImageDataURI</title>
</head>
<body>
<img src="test.jpg" alt="" id="img" />

</body>
<script>
"use strict";

//  getImageDataURI 使用HTMLCanvasElement.toDataURL()获得图片的DataURI编码
/*
 *  因为 toDataURL() 方法对图片进行编码后的返回值并不是图片真实的base64数据组成的DataURI，而是有更多的数据。
 *  所以对该函数获得的DataURI再解码为图片后，图片大小会有较明显的增长，quality越大则增长越明显。
 *  在保存和传输的时候，可以考虑降低质量
 *
 *
 *  source_img_node参数：需要转换的图片的img节点
 *
 *	quality参数：范围为[0,1]，默认为0.92，超出范围的使用默认值
 * 
 *  output_format参数：
 *    * output_format参数相当于false时，如果图片类型为 jpg、jpeg、webp，则转化为DataURI之后的类型保持不变，否则转化后的类型都是png
 *    * output_format参数为"image/jpeg"时，则转化为DataURI之后的类型为jpg
 *    * output_format参数为"image/webp"时，则转化为DataURI之后的类型为webp
 *
 *  返回值：一个两项数组
 *    1. 第一项是toDataURL()方法的返回值，可以作为图片地址直接使用
 *    2. 第二项是其中的base64编码部分
 */
 
function getImageDataURI(source_img_node, quality, output_format="image/png")
{	 
	let sourceImgSrc = source_img_node.src,
		sourceImgType = sourceImgSrc.slice(sourceImgSrc.lastIndexOf(".")+1);
	
	let output_format_arg = arguments[2];
	if( output_format_arg )
	{
		if( output_format_arg==="image/jpeg" || output_format_arg==="image/webp" )
		{
			output_format = output_format_arg;
		}
	}
	else if( sourceImgType==="jpg" || sourceImgType==="jpeg" )
	{	
		output_format  = "image/jpeg";
	}
	else if( sourceImgType==="webp" )
	{
		output_format  = "image/webp";
	}
	
	var cvs = document.createElement('canvas');
	cvs.width = source_img_node.naturalWidth;
	cvs.height = source_img_node.naturalHeight;
	var ctx = cvs.getContext("2d").drawImage(source_img_node, 0, 0);
	var newImageData = cvs.toDataURL(output_format, quality);

	return [newImageData, newImageData.split(',')[1]];
}


//  example

let img = document.getElementById("img");
img.addEventListener("load", function()
{	
	console.log( getImageDataURI(img)[0]);
	console.log( getImageDataURI(img)[1] );
});


</script>
</html>
