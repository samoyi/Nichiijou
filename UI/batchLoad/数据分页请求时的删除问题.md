# 数据分页请求时的删除问题

## 场景
1. 列表数据，前端分页显示，每页4个。
2. 后端数据较多，假设200个，不能一起请求所有的数据。


## 没有删除需求情况下的思路
1. 因为每条数据量其实并不大，所以显然不能每次只请求一页的4个数据
2. 假如每次请求10页的数据，即40个。
3. 刚进入页面时，直接请求40个，记为第一批次，存入已请求的批次数组`batches`，值为`[0]`。同时后端还要返回全部条目数`total`，值为`200`。
4. 创建本地的全部数据数组`allItems`，保存请求到的所有数据。初始化该数组时，要将其长度设定为全部条目数，即`Array(200)`。
5. 将本次请求到的所有40条数据(`newItems`)存入`allItems`：`allItems.splice(0, 40, ...newItems)`。要提前设定总长度和不能直接 push 的原因，下面可以看到。
6. 这时虽然只请求了10页的数据，但分页器也要必须根据总数据量显示所有条目数所形成的页码，这个例子中，分页器的最大页码此时就应是`50`。
7. 在通过分页器切换页面，判断当前页码，是否已经在之前的批次里请求过：
    * 例如切换到`5`页，则根据`batches`可以判断该页数据已经请求，因此不需要再请求
    * 如果切换到`15`页，则根据`batches`可以判断该页数据尚未请求，所以需要请求该页所在批次，即41-80条数据，并让`batches`变为`[0, 1]`；并把新请求到的数据`newItems`插入`items`，即`items.splice(40, 40, ...newItems)`。
    * 如果切换到`50`页，则根据`batches`可以判断该页数据尚未请求，所以需要请求该页所在批次，即161-200条数据，并让`batches`变为`[0, 4]`；并把新请求到的数据数组`newItems`插入`items`，即`items.splice(160, 40, ...newItems)`。


## 如果可以删除条目
1. 比如现在页面打开，请求了前10页的40条数据。
2. 用户删除了第一条数据，首先要向后端发送该删除请求。返回删除成功后，前端删除该条。第一页数据会自动变化，即原本第二页的第一条数据现在移动到第一页的第四个。用户现在点击1-9之间的任何页码，都不会有问题。
3. 但现在，用户点击第10页。按照上面的逻辑，`10`仍属于第一批次，所以不会请求数据。但显然，现在第10页少了一条数据。而且，如果此时点击了第11页，要怎么加载数据？


## 分以下情况思考
* 只加载了前10页，删除前10页中的某个数据后，加载第40条数据，补到10页。本次加载请求需要强制刷新后端数据
    * 如果点击第10页，没问题
    * 如果点击第11页，加载41-80条数据，因为已经是刷新过的了，没问题
    * 如果点击第21页，加载81-99条数据，因为已经是刷新过的了，没问题
* 加载了前20页，删除前20页中的某个数据后，加载现在的第80条数据，补到20页。本次加载请求需要强制刷新后端数据
    * 如果点击第20页，没问题
    * 如果点击第21页，加载81-99条数据，因为已经是刷新过的了，没问题
* 加载了前10页和后10页：
    * 删除前10页中的某个数据后，加载现在的第40条数据，补到10页；最后40条数据 shift 第一条。本次加载请求需要强制刷新后端数据
    * 删除后10页中的某个数据后，没问题
* 加载了前10页和21-30页：
    * 删除前10页中的某个数据后，加载现在的第40条数据，补到10页；21-30批次的数据 shift 第一条，再 push 其后的一条。本次加载请求需要强制刷新后端数据
    * 删除21-30页中的某个数据后，加载现在的第120条数据，补到30页。本次加载请求需要强制刷新后端数据
* 加载了全部的50页，删除后没问题


## 将上面各种情况统一起来的逻辑
1. 如果删除了某个批次的一条数据，该批次前面批次的数据不变
2. 加载原先该批次之后的一条数据，push 到该批次
3. 该批次之后如果还有其他批次（包括最后一批），都 shift 掉第一条数据，然后加载原先本批次之后的一条数据（如果本批次是最后一批次，则不存在之后的一条数据，因此需要加判断）push 到本批次。


## 文件说明
文件 | 内容
--|--
`index.js` | API 服务器
`index.html` | 前端页面
`data.json` | 数据文件。删除数据会改写该文件
`data-copy.json` | 原始数据文件的备份，用来将`data.json`恢复成最初的数据
`resetData.js` | 将`data.json`恢复成最初的数据
